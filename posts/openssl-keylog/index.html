<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Inspecting non-HTTPS TLS traffic - rebeagle</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:image" content><meta property="og:title" content="Inspecting non-HTTPS TLS traffic"><meta property="og:description" content="Inspecting TLS traffic from a browser or any application that works with an HTTPS proxy is straight-forward in most cases. Browser support for SSLKEYLOGFILE or mitmproxy (if you control the trusted CA list the application uses and it doesn&rsquo;t use certificate pinning) address these scenarios respectively. I ran into a scenario recently where I wanted to inspect non-HTTP TLS traffic from a .NET library."><meta property="og:type" content="article"><meta property="og:url" content="/posts/openssl-keylog/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-27T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Inspecting non-HTTPS TLS traffic"><meta name=twitter:description content="Inspecting TLS traffic from a browser or any application that works with an HTTPS proxy is straight-forward in most cases. Browser support for SSLKEYLOGFILE or mitmproxy (if you control the trusted CA list the application uses and it doesn&rsquo;t use certificate pinning) address these scenarios respectively. I ran into a scenario recently where I wanted to inspect non-HTTP TLS traffic from a .NET library."><script src=/js/feather.min.js></script><link href=/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css href=/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=/><img src=/ico.svg style=width:3em></a></div><nav><div><a href=/posts>Posts</a>
<a href=/projects>Projects</a>
<a href=/about>About</a></div>&nbsp;|<div id=icons><a class=soc href=https://github.com/wpbrown title=GitHub><i data-feather=github></i></a></div></nav></header><main><article><div class=title><h1 class=title>Inspecting non-HTTPS TLS traffic</h1><div class=meta>Posted on Feb 27, 2021</div></div><section class=body><p>Inspecting TLS traffic from a browser or any application that works with an HTTPS proxy is straight-forward in most cases. Browser support for SSLKEYLOGFILE or <a href=https://mitmproxy.org/>mitmproxy</a> (if you control the trusted CA list the application uses and it doesn&rsquo;t use certificate pinning) address these scenarios respectively. I ran into a scenario recently where I wanted to inspect non-HTTP TLS traffic from a .NET library.</p><p>The default .NET HTTP client respects the standard <code>HTTP_PROXY</code> environment variables, but that didn&rsquo;t help in this case. Internally the library is using <a href=https://github.com/Azure/DotNetty>DotNetty</a> which in turn is using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.security.sslstream?view=net-5.0">SslStream</a>. At this time, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.security.sslstream?view=net-5.0">SslStream</a> <a href=https://github.com/dotnet/runtime/issues/37915>doesn&rsquo;t support</a> exporting <a href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format>the secrets</a> required to decrypt TLS traffic.</p><p>I came across <a href=https://security.stackexchange.com/questions/80158/extract-pre-master-keys-from-an-openssl-application/80174#80174>this post</a> from Peter Wu. He links to a .c file for building a library that can wrap the OpenSSL context initialization function calls and adds SSLKEYLOGFILE file support to any application (that dynamically links OpenSSL). Unfortunately it didn&rsquo;t work with .NET executables. It <a href=https://github.com/dotnet/runtime/blob/7b993282b47390eadb9cf2bcbec65c6d920cb94d/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.c>turns out</a> that the .NET runtime <code>dlopen</code>s the OpenSSL .so directly and then passes the object handle to <a href=https://man7.org/linux/man-pages/man3/dlvsym.3.html><code>dlsym</code></a>. <code>dlsym</code> will only search that object and its dependencies for symbols, so it won&rsquo;t find the <code>SSL_new</code> wrapper symbol that was loaded via LD_PRELOAD.</p><p>In order to solve this problem, we can also intercept <code>dlsym</code> itself and ensure it always returns the wrapped <code>SSL_new</code> from our library and not the real one from the object handle passed in. I&rsquo;ve done that and published the result as <a href=https://github.com/wpbrown/openssl-keylog>openssl-keylog</a>. There is a convenience wrapper script called <code>dumpcapssl</code> that greatly simplifies making capture files + SSL secrets.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ dumpcapssl eth0 ./SimulatedDevice
*** SSL keys: /tmp/dumpcapssl-BsybG1mk.keys ***
*** Capture : /tmp/dumpcapssl-BsybG1mk.pcapng from interface: eth0 ***
*** Starting Capture ***
Capturing on <span style=color:#e6db74>&#39;eth0&#39;</span>
File: /tmp/dumpcapssl-BsybG1mk.pcapng
*** Starting Command ***
IoT Hub - Simulated Mqtt device.
Press control-C to exit.
...
^C
Exiting...
Device simulator finished.
*** Command Stopped ***
*** Stopping Capture ***
Packets captured: <span style=color:#ae81ff>556</span>
Packets received/dropped on interface <span style=color:#e6db74>&#39;eth0&#39;</span>: 556/0 <span style=color:#f92672>(</span>pcap:0/dumpcap:0/flushed:0/ps_ifdrop:0<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>100.0%<span style=color:#f92672>)</span>
*** Stopped Capture : /tmp/dumpcapssl-BsybG1mk.pcapng Keys: /tmp/dumpcapssl-BsybG1mk.keys ***
</code></pre></div><p>The .keys file can be used in the Wireshark <a href=https://wiki.wireshark.org/TLS>TLS preferences</a> to decrypt the capture.</p><p><a href=wireshark.png target=_blank><img src=wireshark.png alt="decrypted packets in wireshark"></a></p></section><div class=post-tags></div></article></main><footer><br><hr><a href=/>rebeagle</a></footer><script>feather.replace()</script></div></body></html>